# 函数柯里化

1. 是什么？
  - 把带有多个参数的函数转换成一系列的嵌套函数，他返回一个新函数
2. 作用
  - 用于创建已经设置好一个或者多个参数的函数。 函数柯里化的基本方法和函数绑定是一样的：使用一个闭包返回一个函数，两者的区别在于当函数被调用时，返回的函数还需要设置一些传入的参数
3. 
  - 优点：避免拼单的调用具有相同参数的函数
  
## 初级理解

- 如果一个商店每天折扣不同，那么通常写一个函数是这样的，但是这样每次都要输入折扣和价格
```javascript
function discount(dis, price) {
  return dis * 0.01 * price;
}
discount(2, 200)
discount(4, 200)
```

- 柯里化的写法, 这样每次输入价格就可以了
```javascript
function discount2(dis) {
  return function(price) {
    return dis * 0.1 * price;
  };
}
// 五折
const fiveDiscount = discount2(5);
// 四折
const fourDiscount = discount2(4);

fiveDiscount(300)   // 150
fourDiscount(300)  // 120

```

## 柯里化

1. 函数柯里化通常与以下步骤动态创建：
   - 调用另一个函数并为他传入要`柯里化的函数`和`必要参数`
```javascript

/* 该例来自《javascript高级程序设计》 */
function curry(fn) {
  // curry 第一个参数是要进行柯里化的函数，其他参数是要传入的值
  // 获取第一个参数外的其他参数
  var args = Array.prototype.slice.call(arguments, 1); // args,包含了来自外部函数
  return function() {
    var innerArgs = Array.prototype.slice.call(arguments); // innerArgs，用来存放内部函数的所有参数
    var finalArgs = args.concat(innerArgs); // finalArgs，内部外部所有的参数
    return fn.apply(null, finalArgs); // 使用apply将结果传递给函数 fn
  };
}

function add(num1, num2) {
  return num1 + num2;
}
const curriedAdd = curry(add, 5);
// 3成为add的第二个参数
curriedAdd(3);  // 8
// 也可以像这样，一次给出所有参数
const curriedAdd2 = curry(add, 5, 3);
// 3成为add的第二个参数
curriedAdd();  // 8



```

## 使用函数柯里化实现 bind

```javascript
function bind(fn, context) {
  var args = Array.prototype.slice.call(arguments, 2); // args,包含了来自外部函数
  return function() {
    var innerArgs = Array.prototype.slice.call(arguments); // innerArgs，用来存放内部函数的所有参数
    var finalArgs = args.concat(innerArgs); // finalArgs，内部外部所有的参数
    return fn.apply(context, finalArgs); // 使用apply将结果传递给函数 fn
  };
}

const person = {
  name: "hong",
  sayName: function() {
    console.log(this.name);
  } 
};
global.name = "ming";
person.sayName();             // "hong"
bind(person.sayName, null)(); // "ming"

```


## 柯里化升级版

```javascript

/**
 * @des 通用的柯里化函数
 * @param {Function} fn 希望可以柯里化的函数
 * @param {*} [参数们]
 * @return {Function} 柯里化之后的函数
 */
function curry(fn, ...args) {
  return (..._args) => fn(...args, ..._args);
}

```

# 我的疑问？

```javascript
// 为什么不是 90
function discount2(dis) {
  return function(price) {
    return dis * 0.1 * price;
  };
}
// 五折
const threeDiscount = discount2(3);
threeDiscount(300);  // 90.00000000000001

```