## 原型和原型链

- 无论什么时候，只要我们创建了一个函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个`construct`（构造函数）属性，这个属性包含一个指向`prototype`属性所在函数的指针，而通过这个构造函数，我们还可以为函数原型添加其他属性和方法


1. 我们创建的每个函数都有一个 prototype 属性，这个属性是一个指针，指向一个对象
2. 指向的这个对象的用途呢，是包含可以由特定类型的所有实例共享的属性和方法；
3. 字面意思：prototype 就是通过调用构造函数创建的那个对象实例的原型对象；
4. 使用对象原型的好处：可以让他的所有实例，共享他包含的属性和方法；
5. 换句话说，不必在构造函数中定义对象实例的信息，而是可以直接将这些实例添加到原型对象中；
6. 只要新建一个函数，都会根据一组特定的规则为函数创建prototype属性，这个属性指向函数的原型对象；
7. 在默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针；
8. 创建了自定义的构造函数后，其原型对象默认只会取得constructor属性，至于其他方法，都是从Object继承来的；
9. 当调用构造函数创建第一个实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象
  - ECMA-262管那个指针叫[[prototype]]，
  - 在脚本中没有标准的方式访问，但是在 Forefox, Safari 和Chrome在每个对象上都支持一个属性__proto__ ， 去访问该实例的构造函数的原型；
  - 而在其他实现中，这个属性对脚本是完全不可见的；
  - 注意：这个连接，存在于‘实例’ 和 ‘ 构造函数’ 的原型之间，而不是 ’实例‘ 和 ’构造函数‘ 之间


```javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    alert(this.name);
  };
}

const person1 = new Person();
const person2 = new Person();
```

<img src="/Blog/images/原型链表示图.png" title="原型链表示图" width="70%" height="50%">