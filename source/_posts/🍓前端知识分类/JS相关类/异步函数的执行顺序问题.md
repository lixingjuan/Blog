
# 任务分类

- 同步任务
- 异步任务
- 延时任务

# 精细划分

- 宏任务：IO设备事件/setTimeout/serInterval
- 微任务：promise.then(catch/finally), MutationObserver
- （注：promise是声明立即执行， .then 是微任务）

#### 执行顺序

- 依次从上向下执行
    - 遇到同步语句 >> 立即执行
    - 遇到宏任务 >> 放在宏任务队列
    - 遇到微任务 >> 放在微任务队列
- 先返回执行同级的微任务
    - 遇到同步语句 >> 立即执行
    - 遇到宏任务 >> 放在宏任务队列
    - 遇到微任务 >> 放在微任务队列
- （同级的微任务队列中没有微任务）再返回执行宏任务
    - 拿出一个宏任务，按照上面的步骤执行即可

！宏任务的队列是全局的
！同级的微任务队列没有微任务时再去查找宏任务队列

#### 举例

> 下面的代码b并不会等事件a完全执行完毕再执行
> 在延迟函数被触发的过程中就执行了函数b
> 当js引擎的event 队列空闲时才会去执行队列里等待的setTimeout的回调函数
> 调用 setTimeout 函数会在一个时间段过去后在队列中添加一个消息。这个时间段作为函数的第二个参数被传入。如果队列中没有其它消息，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少的时间 而非确切的时间

```JavaScript
// eg.1 异步函数执行顺序问题
function a() {
  setTimeout(() => {
    console.log('执行a函数的延迟函数')
  }, 3000)
  console.log('执行a函数')
}
function b() {
  console.log('执行b函数')
}
a();
b();
// 执行a函数
// VM640:8 执行b函数
// undefined
// VM640:3 执行a函数的延迟函数

```