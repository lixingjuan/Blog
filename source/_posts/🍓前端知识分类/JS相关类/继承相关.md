# 继承相关

实现继承的方法有
1. 原型链继承
2. 借用构造函数
3. 组合式继承
4. 原型式继承
5. 寄生式继承
6. 组合寄生式继承

## 原型继承

- 实现方法：通过修改对象的原型指向来实现原型继承

```javascript
function Father() {
  this.colors = ["red", "green"];
}
function Son() {}
Son.prototype = new Father(); // 使Son的原型指向Father的实例
const instance1 = new Son();
const instance2 = new Son();

console.log(Father.prototype.isPrototypeOf(instance1));
console.log(Father.prototype.isPrototypeOf(instance2));
```

<img src='/Blog/images/原型继承流程图.jpeg'> 


<br>

> 原型链继承问题1，包含引用类型值的原型，包含引用类型值的原型属性会被所有实例共享；
> 再通过原型实现继承时，原型实际上会变成另一个类型的实例，于是，原先的实例属性`(new Father()的属性)`也就变成现在的原型属性`instance1和instance2的原型属性`了

<br>

```javascript
// 修改 instance1 的属性
instance1.colors.push("black");
console.log(instance1.colors); // [ 'red', 'green', 'black' ]
// 发现 instance2的属性值也会随之改变
console.log(instance2.colors); // [ 'red', 'green', 'black' ]
```

<br>

- 这个例子中的Father 构造函数定义了一个colors属性，该属性包含一个数组（引用类型值）。Father的每个实例都会有各自包含各自数组的colors属性；
- 当Son通过原型链继承了Father之后，Son.prototype就变成了Father的一个实例，因此它也拥有一个他自己的colors属性————就跟专门创建了一个 Son.prototype.colors属性一样；
- 但是结果是什么呢？结果是，Son 的所有实例都会共享这一个colors属性。当我们对instance1.colors的修改能够通过 instance2.colors反映出来；

<br>

> 原型链继承问题2：在创建子类型的实例时，不能向超类型的构造函数中传递参数。
> 准确点讲，是没有办法在不影响所有对象实例的情况下，给 超类型的构造函数传递参数

- 综上，实践中很少会单独使用原型链；




## 借用构造函数继承

> 实现思想，通过 `call()` 或 `apply()`方法，在（将来）新创建的对象上执行构造函数
> 我们实际上实在新创建的 `Son` 实例的环境中，调用了 `Father` 构造函数
> 这样一来，就会在 `Son` 对象上执行 `Father` 函数中定义的所有对象初始化代码
> 结果，每个 `Son` 的实例都会拥有自己的 `colors`属性 的副本了

```javascript

/* 借用构造函数实现继承 */
function Father() {
  this.colors = ["res", "green"];
}

function Son() {
// 当使用new操作符创建Son的实例的时候，this指向实例
  Father.call(this);
}

const instance1 = new Son();
const instance2 = new Son();

// 修改 instance1 的colors 属性
instance1.colors.push("pink");
console.log(instance2.colors); // ["res", "green"]
// 发现 instance2.colors 属性值并未受影响，解决了原型继承时，引用类型所带来的实例共享问题

```

> 与原型继承相比，借用构造函数有一个很大的优点，可以在子类构造函数中，向超类型构造函数传递参数

```javascript

function Father(name) {
  this.name = name;
}

function Son() {
  // 向父类构造函数传递参数 name
  Father.call(this, "Tom");
  // 为 Son 的实例设置 name 属性
  // 为避免 Father构造函数不会重写此处添加的子类属性，在调用超类型构造函数后添加自定义属性
  this.age = 25;
}

const instance1 = new Son();
console.log(instance1.name);  // ‘Tom’
console.log(instance1.age);   // 25

```

> 仍存在的问题：方法都在构造函数内部定义，函数复用性差；

- 因此，借用构造函数的方法也很少单独使用


## 组合继承


> 结合原型链继承 和 借用构造函数继承, 发挥二者之长
> 思路：使用原型链实现对 **原型属性和方法** 的继承，而通过借用构造函数实现对 **实例属性的继承**


```javascript

/* 组合继承 */
function Father(name) {
  this.name = name;
  this.colors = ["red", "green"];
}

Father.prototype.sayName = function() {
  console.log(this.name);
};

function Son(name, age) {
  Father.call(this, name);
  this.age = age;
}

// 继承方法
Son.prototype = new Father(); // Son 的原型指向 Father的实例
Son.prototype.constructor = Son;
Son.prototype.sayAge = function() {
  console.log(this.age);
};

const instance1 = new Son("Tom", 24);
instance1.sayName(); // 'Tom'
instance1.sayAge(); // 24
instance1.colors.push("pink");
console.log(instance1.colors); // [ 'red', 'green', 'pink' ]

const instance2 = new Son("Marry", 12);
instance2.sayName(); // 'Marry'
instance2.sayAge(); // 12
instance2.colors.push("black");
console.log(instance2.colors); // [ 'red', 'green', 'black' ]

```

- 在该例子中，Father 构造函数定义了两个属性： name和colors, Father的原型定义了一个方法 sayName().
- Son 构造函数在调用 Father 构造函数时传入了name 参数，紧接着又定义了自己的属性 age;
- 然后，将 Father 的实例赋值给 Son 的原型；
- 然后，又在该新原型上定义了方法 sayAge()
- 这样一来，就可以让两个不同的 Son 实例，分别拥有自己的属性————包括colros属性，

> 组合继承避免了原型链和借用构造函数的缺陷，融合了他们的优点，是最常用的继承方式
> 同时，instanceof 和isPrototypeOf() 也能够用于识别基于组合继承创建的对象