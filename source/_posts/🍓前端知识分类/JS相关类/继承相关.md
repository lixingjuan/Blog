## 原型继承

- 实现方法：通过修改对象的原型指向来实现原型继承

```javascript
function Father() {
  this.colors = ["red", "green"];
}
function Son() {}
Son.prototype = new Father(); // 使Son的原型指向Father的实例
const instance1 = new Son();
const instance2 = new Son();

console.log(Father.prototype.isPrototypeOf(instance1));
console.log(Father.prototype.isPrototypeOf(instance2));
```

<img src='/Blog/images/原型继承流程图.jpeg'> 


<br>

> 原型链继承问题1，包含引用类型值的原型，包含引用类型值的原型属性会被所有实例共享；
> 再通过原型实现继承时，原型实际上会变成另一个类型的实例，于是，原先的实例属性`(new Father()的属性)`也就变成现在的原型属性`instance1和instance2的原型属性`了

<br>

```javascript
// 修改 instance1 的属性
instance1.colors.push("black");
console.log(instance1.colors); // [ 'red', 'green', 'black' ]
// 发现 instance2的属性值也会随之改变
console.log(instance2.colors); // [ 'red', 'green', 'black' ]
```

<br>

- 这个例子中的Father 构造函数定义了一个colors属性，该属性包含一个数组（引用类型值）。Father的每个实例都会有各自包含各自数组的colors属性；
- 当Son通过原型链继承了Father之后，Son.prototype就变成了Father的一个实例，因此它也拥有一个他自己的colors属性————就跟专门创建了一个 Son.prototype.colors属性一样；
- 但是结果是什么呢？结果是，Son 的所有实例都会共享这一个colors属性。当我们对instance1.colors的修改能够通过 instance2.colors反映出来；

<br>

> 原型链继承问题2：在创建子类型的实例时，不能向超类型的构造函数中传递参数。
> 准确点讲，是没有办法在不影响所有对象实例的情况下，给 超类型的构造函数传递参数

- 综上，实践中很少会单独使用原型链；




## 借用构造函数继承
