## new Vue

当我们执行new Vue的时候，实际上会调用`init.js`执行一系列的初始化
1. 合并options;
2. 初始化data、生命周期、methods、等等;

## $mount

```javascript
if(complier版本){

  /* doSomething to el */
  if(el挂载在 body or html){
    // 警告
  }

  /* 先，尝试获取templete(因为有多种定义templete) */
  /* 然后，获取到之后，使用compileToFunctions将其编译为render函数 */

  /* 最后，mount,挂载 */
  return mount.call(this, el, hydrating)
}
```


## render



`render`函数会遇到两种情况：
1. 模版类的化，调用 vm._c方法
2. 手写的`render`, 调用`vm.$createElement`

这两个方法的却比在于参数6，方法1是false, 方法2是true
而这两个方法，最终都会调用 `createElement`方法，返回一个`VNode`


<!-- 3. createElement:(在initRender阶段执行的) -->
<!-- 将我们的DOM编译为virtual -->
<!--  -->
<!-- ```js -->
<!-- <Templete> -->
  <!-- <div id='page-container'> -->
    <!-- {{ message }} -->
  <!-- </div> -->
<!-- <Templete/> -->
<!--  -->
<!-- <script> -->
<!-- export default { -->
  <!-- data(){ -->
    <!-- return { -->
      <!-- message: 'Hello World!' -->
    <!-- } -->
  <!-- } -->
<!-- } -->
<!-- </script> -->
<!-- ``` -->

<!-- 相当于 -->

<!-- ```js -->
<!-- /** -->
 <!-- * @des createElement -->
 <!-- * @param {Function} createElement  -->
 <!-- * @return:  -->
 <!-- */ -->
<!-- render(createElement){ -->
  <!-- return createElement('div', {    -->
    <!-- attr: { -->
      <!-- id: '#page-container' -->
    <!-- } -->
  <!-- }, this.message) -->
<!-- } -->
<!-- ``` -->

2. proxy: (在initRender阶段执行的)
对象访问做一个劫持，进行一些判断（如，变量render时未定义、模版否有多个根结点），然后发出一些警告

## virtual Node-VNode

virtual Node 的出现是因为操作DOM是比较耗费性能的，于是有了virtual Node 来描述DOM，VNode是virtual Node 在vue中的具体应用（借鉴自开源库snabbdom）；
VNode实际上是一个对象，去描述DOM结点。包含各种属性，如标签名、数据、子节点、键值等属性，还有一些用来拓展VNode的灵活性以及实现一些特殊的feature；
由于VNode只是映射到真实DOM的渲染，不需要包含操作DOM的方法，所以他是非常轻量和简单的；

virtual Node 除了他的数据结构和定义，映射到真实的DOM实际上要经历VNode的create、diff、patch等过程；

在vue中，create ,即createElement；

## createElement

vue.js使用`createElement`创建`VNode`，定义在 `src/core/create-element.js`中；
`createElement`实际上是对 `_createElement`做了一层封装，它允许传入的参数更加灵活，在处理完这些参数后，再去调用真正创建 `VNode`的函数 `_createElement`；

=> 见源码-createElement.md


大致了解了 `createElement` 创建 `VNode`的过程， 每个 `VNode`都有 `children`, `children` 每个元素也是一个 `VNode`，这样就形成了 **VNode Tree**, 他很好的描述了我们的 **DOM tree**

回到 mountComponent 函数的过程，我们已经知道 `vm._render` 是如何创建了一个 `VNode`，接下来就是要把这个`VNode`渲染为一个真实的DOM并渲染出来，这个过程是通过 vm._update完成的;


## _update

_update 方法的主要作用就是将 VNode 渲染为真实 DOM，定义在 `src/core/instance/lifecycle.js` 中；
_update 是vue 实例的一个私有方法，他被调用的时机有两个：
1. 一个是首次渲染；
2. 另一个是数据更新的时候；(响应式原理)

详见 => _update.md


## 组件化

vue 的另一个核心就是允许我们吧页面拆分为多个组件，每个组件依赖的css,jsvascript，模版，图片放在一起开发和维护；
组件是资源独立的，组件在系统内部可复用，组件和组件之前可以嵌套；

vue组件初始化的一个过程如下

```js
import Vue from 'vue'
import App from './App.vue'

var app = new Vue({
  el:'#app',
  // 这里的 h 是createElement 方法
  render: h => h(App)
})
```

这段代码是使用render函数去渲染的，不同的是，这次通过 createElement 传入的是一个组件而不是一个原生的标签，如下继续分析这一过程；

## createComponent


createComponent 是实现组件化的关键

在分析createElement的实现的时候，最终会调用 _createElement 方法，其中有一段逻辑是对参数tag的判断=> 
1. 如果一个普通的html标签, (如 div), 则会实例化一个普通的VNode节点;
2. 如果不是，则通过 createComponent 方法创建一个组件 VNode;

详见 => 源码-createComponent.md 

## patch

patch过程把 VNode 转换成真正的DOM节点。
通过之前的分析可知，再通过createComponet创建了组件Vnode, 接下来会走到vm._update, 执行vm.`__patch__` 去吧 VNode 转换成真正的DOM节点，但是针对一个普通的VNode节点，VNode创建过程有所不同。

详见 => 源码-patch.md